<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classic Atari Pong</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', monospace;
            color: white;
        }
        #gameCanvas {
            border: 2px solid #fff;
            background-color: #000;
        }
        #gameOverlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            z-index: 10;
        }
        #gameOverlay h1 {
            font-size: 48px;
            margin-bottom: 20px;
        }
        #gameOverlay p {
            font-size: 24px;
            margin: 10px 0;
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 14px;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="400"></canvas>
    <div id="gameOverlay">
        <h1 id="overlayTitle">PONG</h1>
        <p id="overlayMessage">Press SPACE to Start</p>
        <p>Player 1: W/S • Player 2: ↑/↓ • SPACE: Pause/Resume</p>
    </div>
    <div class="controls">
        Player 1: W/S keys • Player 2: Arrow keys • SPACE: Pause/Resume • R: Restart
    </div>

    <script>
        // Game Constants
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 400;
        const PADDLE_WIDTH = 15;
        const PADDLE_HEIGHT = 80;
        const BALL_RADIUS = 8;
        const PADDLE_SPEED = 5;
        const BALL_SPEED = 4;
        const WINNING_SCORE = 5;

        // Game States
        const GameStates = {
            MENU: 'menu',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'gameOver'
        };

        // Math Utilities
        class MathUtils {
            static clamp(value, min, max) {
                return Math.min(Math.max(value, min), max);
            }

            static lerp(start, end, factor) {
                return start + (end - start) * factor;
            }

            static distance(x1, y1, x2, y2) {
                return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            }

            static randomBetween(min, max) {
                return Math.random() * (max - min) + min;
            }
        }

        // Paddle Class
        class Paddle {
            constructor(x, y, isPlayer1 = true) {
                this.x = x;
                this.y = y;
                this.width = PADDLE_WIDTH;
                this.height = PADDLE_HEIGHT;
                this.velocity = 0;
                this.speed = PADDLE_SPEED;
                this.isPlayer1 = isPlayer1;
            }

            update() {
                this.y += this.velocity;
                this.y = MathUtils.clamp(this.y, 0, GAME_HEIGHT - this.height);
            }

            moveUp() {
                this.velocity = -this.speed;
            }

            moveDown() {
                this.velocity = this.speed;
            }

            stop() {
                this.velocity = 0;
            }

            draw(ctx) {
                ctx.fillStyle = '#fff';
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }

            getBounds() {
                return {
                    left: this.x,
                    right: this.x + this.width,
                    top: this.y,
                    bottom: this.y + this.height
                };
            }
        }

        // Ball Class
        class Ball {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = BALL_RADIUS;
                this.velocityX = BALL_SPEED;
                this.velocityY = 0;
                this.speed = BALL_SPEED;
                this.trail = [];
                this.maxTrailLength = 8;
            }

            update() {
                // Update trail
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }

                // Update position
                this.x += this.velocityX;
                this.y += this.velocityY;

                // Bounce off top and bottom walls
                if (this.y - this.radius <= 0 || this.y + this.radius >= GAME_HEIGHT) {
                    this.velocityY = -this.velocityY;
                    audioManager.playBounce();
                }
            }

            reset() {
                this.x = GAME_WIDTH / 2;
                this.y = GAME_HEIGHT / 2;
                this.velocityX = this.velocityX > 0 ? -BALL_SPEED : BALL_SPEED;
                this.velocityY = MathUtils.randomBetween(-2, 2);
                this.trail = [];
            }

            draw(ctx) {
                // Draw trail
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                for (let i = 1; i < this.trail.length; i++) {
                    const alpha = i / this.trail.length * 0.3;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.beginPath();
                    ctx.moveTo(this.trail[i - 1].x, this.trail[i - 1].y);
                    ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    ctx.stroke();
                }

                // Draw ball
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            getBounds() {
                return {
                    left: this.x - this.radius,
                    right: this.x + this.radius,
                    top: this.y - this.radius,
                    bottom: this.y + this.radius
                };
            }
        }

        // ScoreBoard Class
        class ScoreBoard {
            constructor() {
                this.player1Score = 0;
                this.player2Score = 0;
            }

            increasePlayer1Score() {
                this.player1Score++;
            }

            increasePlayer2Score() {
                this.player2Score++;
            }

            reset() {
                this.player1Score = 0;
                this.player2Score = 0;
            }

            getWinner() {
                if (this.player1Score >= WINNING_SCORE) return 1;
                if (this.player2Score >= WINNING_SCORE) return 2;
                return null;
            }

            draw(ctx) {
                ctx.fillStyle = '#fff';
                ctx.font = '48px Courier New';
                ctx.textAlign = 'center';
                
                // Draw scores
                ctx.fillText(this.player1Score.toString(), GAME_WIDTH / 4, 60);
                ctx.fillText(this.player2Score.toString(), (GAME_WIDTH * 3) / 4, 60);
                
                // Draw center line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 10]);
                ctx.beginPath();
                ctx.moveTo(GAME_WIDTH / 2, 0);
                ctx.lineTo(GAME_WIDTH / 2, GAME_HEIGHT);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        // Physics Engine
        class PhysicsEngine {
            static checkCollision(ball, paddle) {
                const ballBounds = ball.getBounds();
                const paddleBounds = paddle.getBounds();

                return ballBounds.left < paddleBounds.right &&
                       ballBounds.right > paddleBounds.left &&
                       ballBounds.top < paddleBounds.bottom &&
                       ballBounds.bottom > paddleBounds.top;
            }

            static handlePaddleCollision(ball, paddle) {
                // Calculate hit position on paddle (-1 to 1)
                const hitPos = (ball.y - (paddle.y + paddle.height / 2)) / (paddle.height / 2);
                
                // Reverse horizontal direction
                ball.velocityX = -ball.velocityX;
                
                // Add vertical angle based on hit position
                ball.velocityY = hitPos * 3;
                
                // Slightly increase speed
                const currentSpeed = Math.sqrt(ball.velocityX ** 2 + ball.velocityY ** 2);
                const newSpeed = Math.min(currentSpeed * 1.05, BALL_SPEED * 1.5);
                const normalizer = newSpeed / currentSpeed;
                ball.velocityX *= normalizer;
                ball.velocityY *= normalizer;

                // Prevent ball from getting stuck in paddle
                if (paddle.isPlayer1) {
                    ball.x = paddle.x + paddle.width + ball.radius;
                } else {
                    ball.x = paddle.x - ball.radius;
                }
            }
        }

        // Input Controller
        class InputController {
            constructor() {
                this.keys = {};
                this.setupEventListeners();
            }

            setupEventListeners() {
                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    
                    // Handle pause/resume and restart
                    if (e.code === 'Space') {
                        e.preventDefault();
                        gameManager.togglePause();
                    }
                    if (e.code === 'KeyR') {
                        e.preventDefault();
                        gameManager.restart();
                    }
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
            }

            update(paddle1, paddle2) {
                // Player 1 controls (W/S)
                if (this.keys['KeyW']) {
                    paddle1.moveUp();
                } else if (this.keys['KeyS']) {
                    paddle1.moveDown();
                } else {
                    paddle1.stop();
                }

                // Player 2 controls (Arrow keys)
                if (this.keys['ArrowUp']) {
                    paddle2.moveUp();
                } else if (this.keys['ArrowDown']) {
                    paddle2.moveDown();
                } else {
                    paddle2.stop();
                }
            }
        }

        // Audio Manager
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.initAudio();
            }

            initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API not supported');
                }
            }

            playTone(frequency, duration, volume = 0.1) {
                if (!this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = 'square';

                gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }

            playBounce() {
                this.playTone(800, 0.1);
            }

            playPaddleHit() {
                this.playTone(400, 0.1);
            }

            playScore() {
                this.playTone(600, 0.3);
            }
        }

        // Renderer
        class Renderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
            }

            clear() {
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            }

            render(paddle1, paddle2, ball, scoreBoard) {
                this.clear();
                scoreBoard.draw(this.ctx);
                paddle1.draw(this.ctx);
                paddle2.draw(this.ctx);
                ball.draw(this.ctx);
            }
        }

        // Game Manager
        class GameManager {
            constructor() {
                this.state = GameStates.MENU;
                this.canvas = document.getElementById('gameCanvas');
                this.overlay = document.getElementById('gameOverlay');
                this.overlayTitle = document.getElementById('overlayTitle');
                this.overlayMessage = document.getElementById('overlayMessage');
                
                this.renderer = new Renderer(this.canvas);
                this.inputController = new InputController();
                this.scoreBoard = new ScoreBoard();
                
                this.paddle1 = new Paddle(30, GAME_HEIGHT / 2 - PADDLE_HEIGHT / 2, true);
                this.paddle2 = new Paddle(GAME_WIDTH - 30 - PADDLE_WIDTH, GAME_HEIGHT / 2 - PADDLE_HEIGHT / 2, false);
                this.ball = new Ball(GAME_WIDTH / 2, GAME_HEIGHT / 2);

                this.showOverlay();
            }

            togglePause() {
                if (this.state === GameStates.MENU) {
                    this.startGame();
                } else if (this.state === GameStates.PLAYING) {
                    this.state = GameStates.PAUSED;
                    this.overlayTitle.textContent = 'PAUSED';
                    this.overlayMessage.textContent = 'Press SPACE to Resume';
                    this.showOverlay();
                } else if (this.state === GameStates.PAUSED) {
                    this.state = GameStates.PLAYING;
                    this.hideOverlay();
                } else if (this.state === GameStates.GAME_OVER) {
                    this.restart();
                }
            }

            startGame() {
                this.state = GameStates.PLAYING;
                this.hideOverlay();
                audioManager.audioContext?.resume();
            }

            restart() {
                this.state = GameStates.MENU;
                this.scoreBoard.reset();
                this.ball.reset();
                this.paddle1.y = GAME_HEIGHT / 2 - PADDLE_HEIGHT / 2;
                this.paddle2.y = GAME_HEIGHT / 2 - PADDLE_HEIGHT / 2;
                this.overlayTitle.textContent = 'PONG';
                this.overlayMessage.textContent = 'Press SPACE to Start';
                this.showOverlay();
            }

            showOverlay() {
                this.overlay.style.display = 'block';
            }

            hideOverlay() {
                this.overlay.style.display = 'none';
            }

            update() {
                if (this.state !== GameStates.PLAYING) return;

                // Update input
                this.inputController.update(this.paddle1, this.paddle2);

                // Update game objects
                this.paddle1.update();
                this.paddle2.update();
                this.ball.update();

                // Check paddle collisions
                if (PhysicsEngine.checkCollision(this.ball, this.paddle1)) {
                    PhysicsEngine.handlePaddleCollision(this.ball, this.paddle1);
                    audioManager.playPaddleHit();
                }
                if (PhysicsEngine.checkCollision(this.ball, this.paddle2)) {
                    PhysicsEngine.handlePaddleCollision(this.ball, this.paddle2);
                    audioManager.playPaddleHit();
                }

                // Check scoring
                if (this.ball.x < 0) {
                    this.scoreBoard.increasePlayer2Score();
                    audioManager.playScore();
                    this.ball.reset();
                } else if (this.ball.x > GAME_WIDTH) {
                    this.scoreBoard.increasePlayer1Score();
                    audioManager.playScore();
                    this.ball.reset();
                }

                // Check win condition
                const winner = this.scoreBoard.getWinner();
                if (winner) {
                    this.state = GameStates.GAME_OVER;
                    this.overlayTitle.textContent = `PLAYER ${winner} WINS!`;
                    this.overlayMessage.textContent = 'Press SPACE to Play Again';
                    this.showOverlay();
                }
            }

            render() {
                this.renderer.render(this.paddle1, this.paddle2, this.ball, this.scoreBoard);
            }
        }

        // Initialize game
        const audioManager = new AudioManager();
        const gameManager = new GameManager();

        // Game loop
        function gameLoop() {
            gameManager.update();
            gameManager.render();
            requestAnimationFrame(gameLoop);
        }

        // Start the game loop
        gameLoop();
    </script>
</body>
</html>